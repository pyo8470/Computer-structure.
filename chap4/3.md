# ![image](https://user-images.githubusercontent.com/84065357/171400069-248eb2a6-5554-4566-be40-63b3a0399cb3.png)
>  - 28이란 숫자는 7로 바뀌어야함(오류)
> > - 어차피 7x4(instruction의 크기)=28이기 때문
> - 맨 왼쪽의 숫자는 PC값
> - 72로 뛰는 이유 = PC+값+4이기 때문 
> - 위치 값(PC)이 나오는 단계는 DM이후 임
> > - 따라서 그 사이의 instruction들을 모두 무효로 돌림 
> > - stall 3번 발생
> ## Branch 딜레이를 줄이기.
> > - ALU에서 처리하는게 너무 느림
> > > - 레지스터 두개 비교하기
> > > - 따라서 ID단계에서 Target 주소 더하기
> > > - 이 연산들을 ID단계에서 실행
> > # ![image](https://user-images.githubusercontent.com/84065357/171401912-f668f532-f650-476d-b45b-787e1dc89036.png)
> > # ![image](https://user-images.githubusercontent.com/84065357/171402767-57866f7d-8438-4df0-93db-7f4b9b4796fa.png)
> > > - 72로 뛴다.
> > # ![image](https://user-images.githubusercontent.com/84065357/171403007-b26c9b62-06e0-4617-80e8-43203f5aa17c.png)

## Branch에서의 Data Hazard 
> # ![image](https://user-images.githubusercontent.com/84065357/171403397-8bb46390-6596-45b2-8c1c-ec86f1c1094f.png)
> # ![image](https://user-images.githubusercontent.com/84065357/171403451-71bdb5af-ec2f-44b6-a290-12705c1c333a.png)

## 동적 Branch 예측
> - 규모가 커지면, Branch연산 패널티는 더욱 중요해짐.
> > - 10%의 stall이 발생한다고 생각 -> 2TB크기-> 200GB만큼의 손실을 봄.
> 1. Branch 예측 버퍼(브랜치 히스토리 테이블)
> > - Branch가 과거에 어떻게 되었는지에 대한 기록을 가지고 있음
> 2. 최근 Branch 명령 주소 가지고 있음
> 3. 결과 저장(받아들여지거나 안받아 들여지거나)
> ### 브랜치 수행시
> > 1. table 체크 후 같은 결과가 나올것이라고 예상
> > 2. bracnch 동작 시킴
> > 3. 예측이 틀리면, 그동안의 파이프 라인을 날림
> ## 1비트 예측
> > # ![image](https://user-images.githubusercontent.com/84065357/171408658-d9afe6c2-5ec4-4a5b-b5c3-7a84c7a45a3b.png)
> > - 바로 이전의 Branch가 taken/not taken인지만 저장.
> > ### 한계
> > > - 잘못된 예측이 두번 발생
> > > - for문이라고 가정했을때
> > > - 마지막 for문을 수행하고 빠져나왔을때, not taken이 저장됨
> > > - 그러나 모종상의 이유로 다시 for문으로 왔을때, not taken때문에 다시 루프를 빠져나올려함
> > > - 2번 mispredict 발생
